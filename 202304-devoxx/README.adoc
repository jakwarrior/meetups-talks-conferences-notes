= Devoxx France 2023
Sébastien Crabier
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
:highlightjs-languages: asciidoc
// We must enable experimental attribute to display Keyboard, button, and menu macros
:experimental:
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To number the sections of the table of contents
//:sectnums:
// Add an anchor with hyperlink before the section title
:sectanchors:
// To turn off figure caption labels and numbers
:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
// :caption:

toc::[]

== Présentation du salon

* https://www.devoxx.fr/, du 12 au 14/04/2022

== MERCREDI

Programme du mercredi : https://cfp.devoxx.fr/2023/byday/wed

=== 09h30 - 12h30 : Rendons le DDD aux devs

==== Abstract

Bien qu’étant proche de souffler ses 20 bougies, et malgré de nombreuses tentatives de vulgarisation, Domain-Driven Design (DDD) reste un sujet sur lequel il est difficile de se sentir à l'aise quand on est développeur ou développeuse, et qui semble trop souvent réservé à une élite d'architectes et aux cercles de pouvoir d'une direction informatique. Pourtant, c'est bien dans le rapport direct au code que DDD prend tout son sens ! Dans cette université, nous proposons quelques pratiques précises de code pour vous aider à exprimer davantage de couleur métier dans votre code. Pas à pas, à partir d'une base de code existante et concrète, vous découvrirez comment une série de refactorings simples permet de faire émerger le raisonnement métier au cœur de DDD, et vous serez surpris de pouvoir dire que vous avez enfin vraiment compris et pratiqué DDD !

===== Speakers 

_Dorra Bartaguiz_

Dorra est VP Tech chez Arolla, co-auteure du livre Software Craft (édition Dunod), rédactrice en chef du numéro spécial 100% féminin chez Programmez! (245 Janvier 2022) Elle est passionnée par le développement et les bonnes pratiques. Elle partage son savoir-faire en publiant des articles et en animant des conférences et meetups. Elle a aussi enseigné dans une école d'ingénieurs à Paris pendant des années.

_Arnaud Thiefaine_

Arnaud est développeur, coach craft et formateur chez Arolla. Passionné par la transmission des bonnes pratiques, il est également co-auteur du livre "Software Craft : TDD, Clean Code et autres pratiques essentielles" aux éditions Dunod et anime régulièrement des meetups et BBL autour du Craft.

==== Notes

Le DDD pour « Domain-Driven Design » est appelé en français « Conception pilotée par le domaine ».
(À la place de « pilotée par le domaine », on pourrait utiliser orientée, motivée, justifiée…)
La conception de notre application toute entière est définie sur le design du domaine.
En quelques mots, il s’agit de représenter le métier directement dans le code. Plutôt que de coder le métier.
DDD, c’est une philosophie de conception, on se base sur le métier pour assembler la solution que l’on apporte au business, autrement dit notre code.
Ainsi, la structure, le nom des classes, des champs, les actions des fonctions : tout ceci doit refléter le métier.
Dans le meilleur des mondes, une personne du métier doit presque être capable de comprendre l’intention du code qu’elle est en train de regarder.
Mais le Domain-Driven Design, c’est avant tout la compréhension du métier par l’ensemble de l’équipe.

Le DDD existe depuis 20 ans, ce n'est pas quelque chose de nouveau.
Beaucoup le trouve difficile à appliquer. 

Refactoring de code : partir d'une gold master avec plein de scénarios de test pour ne rien casser, puis faire uniquement des baby steps. A chaque baby steps, rejouer les tests qui doivent toujours passer. Ne pas avoir de tests KO pendant le refactoring, même si on doit parfois complexier le code pour le rendre plus simple plus tard.

image::PXL_20230412_081024919.jpg[alt]

Avec le DDD, le code doit être le plus facilement compréhensible, même pour quelqu'un qui ne fait pas forcément de code. 

Supprimer régulièrement le code inutile, même les commentaires qui ne servent à rien. Est-ce qu'on a vraiment besoin de commentaire à cet endroit précis ? Il vaut mieux renommer une variable ou une méthode, ou d'extraire un bout de code dans une méthode pour rendre l'ensemble plus compréhensible. Supprimer également les logs ou sorties console de debug pour cleaner le code (obvious).

Rapprocher les variables le plus près possible de leur utilisation, pour facilier le refactoring par la suite, comme l'extraction dans une méthode par exemple.

Pattern sandwich = séparation du métier et de la technique. Métier et technique sont souvent entremélé, comme dans un sandwich => se diriger vers le burger, avec le métier au centre (comme le steak), entouré par les buns qui représentent la technique (entrées et sorties qui encadrent la partie métier). La partie métier est ainsi plus facilement compréhensible, et la technique n'est là que pour supporter la partie métier. 

Identification des Bounded Context : identifier les différentes parties métiers à isoler
=> à faire en workshop avec le métier, PO (pas uniquement les devs). Cela permet d'identifier les différents domaines métiers. Asser compliquer à mettre en place et cher (tout le monde doit être présent en même temps).

Exemple de Bounded Context : 

image::https://martinfowler.com/bliki/images/boundedContext/sketch.png[alt]

Tips pour identifier les différentes parties métier :

image::PXL_20230412_084501113.jpg[alt]

Les 3 complexités du logiciel :

image::PXL_20230412_091944776.jpg[alt]

L'architecture hexagonale permet d'isoler le métier de la technique pour supprimer la complexité accidentelle et réduire la complexité obligatoire.
L’architecture hexagonale s’appuie sur trois principes et techniques :

* Séparer explicitement User-Side, Business Logic et Server-Side
* Les dépendances vont vers la Business Logic
* On isole les frontières par des Ports et Adapters

image::PXL_20230412_092215930.jpg[alt]

image::https://blog.octo.com/wp-content/uploads/2020/06/archi_hexa_00-3.png[alt]

image::https://blog.octo.com/wp-content/uploads/2020/06/archi_hexa_06.png[alt]

Les adapteurs adaptent l'extérieur (BDD, etc...) au domaine. Le domaine est isolé donc facilement testable. Il y a juste besoin de mocker la partie infra.

image::PXL_20230412_094023160.jpg[alt]

image::PXL_20230412_094729189.jpg[alt]

image::PXL_20230412_095738225.jpg[alt]

image::PXL_20230412_095826763.jpg[alt]

image::PXL_20230412_100516013.jpg[alt]

image::PXL_20230412_100820488.jpg[alt]

image::PXL_20230412_102030850.jpg[alt]

image::PXL_20230412_102216209.jpg[alt]

=== 13h30 - 16h30 : Automatisez vos tests utilisateurs avec Cypress

==== Abstract

Poussez la porte pour venir découvrir avec nous un outil de testing end-to-end pensé par et pour les développeurs.

Aujourd’hui plesbicité par la communauté, Cypress est la promesse tenue d’une solution pour en finir avec les tests e2e longs et lents, allant jusqu’à proposer aujourd’hui une fonctionnalité de component testing.

Pendant cet atelier, nous explorerons ensemble une application web grâce à Cypress au travers de différents parcours utilisateurs pour découvrir les possibilités offertes par ce framework, ainsi que ses limitations.

===== Speakers 

_Gérôme Grignon_

Développeur Web chez SFEIR.
Consommateur de projets open-source le jour, contributeur la nuit.
Head of OSPO @SFEIR Stackblitz Community Advocate

_Anthony Pena_

Codeur et blogueur le jour et dévoreur de manga la nuit, vous me verrez souvent parler de Java, JavaScript, Typescript, Rust ou de test, parfois un peu (beaucoup) de jeux-vidéos ou de bricolage de console.

==== Notes

Atelier hands-on, présentation des différentes fonctionnalités de Cypress suivies d'exercices.

Les slides :
https://sfeir-open-source.github.io/sfeir-school-cypress/#/

Le dépôt GitHub des exercices :
https://github.com/sfeir-open-source/sfeir-school-cypress

=== 17h00 - 17h30 : NodeJS : patterns et outils pour partir en production sereinement

==== Abstract

Depuis 2009, NodeJS a beaucoup évolué et est devenu une solution particulièrement populaire pour développer des BFF (Backend For Frontend).

Seulement voilà, malgré tous les progrès qui ont été faits, certaines API JS comme les promesses (avec ou sans async/await) apportent une fausse illusion de simplicité. Développer une application NodeJS comporte encore pas mal de pièges.

Lors de cette session, je vous propose de passer en revue les pièges les plus courants, sources de gros plantages en production. Je vous présenterai aussi quelques outils pour éviter les surprises, mieux comprendre ce qui se passe sous le capot, écrire des tests qui permettent d’être vraiment confiants et enfin développer des applications réellement résistantes aux pannes.

==== Speakers

_Alexandre Victoor_

Après plusieurs années à construire des applications pour les salles de marchés d'une grande banque française, je suis aujourd'hui CTO de Comet Meetings.
Passionné par le code, que ce soit en Java, en C# ou en JS, je suis fan de tout ce qui tourne autour de l'agilité et tout particulièrement du craftsmanship.
A mes heures perdues je contribue à des projets open source, le dernier en date étant HdrHistogramJS, un portage en TypeScript de la librairie Java HdrHistogram de Gil Tene.

==== Notes

Plusieurs centaines de paramètres pour la commande node.

4Go de RAM maximum utilisée par défaut par node 18 => penser à limiter la taille max utilisée pour une application en prod qui utilise node.js. Une dizaine de threads utilisés par ailleurs. 

Piscina => permet de faire des pool de thread en node.

AutoCannon => tester la montée en charge de l'application.

NodeClinic (Clinic.js) => équivalent de VisualVM pour Node.

Express permet de construire des applications back-end basé sur node.
Supertest permet de faire des tests avec Express.
Pas de promesses dans Express. Il faut utiliser "express-promise-router"

Zod permet de définir un schéma pour valider des données qui viennent d'un service externe.

Pattern circuit-breaker pour gérer un trop grand nombre d'erreur. Utiliser la librairie cockatiel pour faire des circuit-breaker avec node.

Bulhead : pour éviter que le serveur tombe sous la charge. Cockatiel peut aussi être utilisé dans ce cas.

image::PXL_20230412_152838792.jpg[alt]


=== 17h45 - 18h15 : Résoudre AdventOfCode avec Github Copilot et OpenAI ChatGTP

==== Abstract

Chaque décembre, c'est pas des chocolats, mais des problèmes algorithmiques via adventofcode.
Cette année, j'ai commencé avec Github copilot de branché, et j'ai eu l'impression de tricher. J'ai ensuite testé OpenAI ChatGPT:

* copie-collé l'énoncé texte
* attendre 5 secondes
* copié collé le programme généré
* faire tourner le programme
* Job DONE!

Je vous propose de voir en live ce qu'on arrive à faire avec ces outils, notamment face à ce genre de puzzles, et aussi voir leurs limites.
Enfin, on verra si c'est vraiment tricher ou pas et comment ces outils changerons nos métiers de développeurs.

==== Speakers

_Benoît Lafontaine_

Engineering Director à Doctolib, ex directeur technique OCTO Technology. Développe sur son temps libre plein de choses inutiles. Cherche toujours à trouver comment aller plus vite en faisant mieux (est passé du coup du Java à Ruby:) ). Persuadé que « team => product » et que le code est un art.

==== Notes

Github Copilot est un outil très puissant, aide à l'écriture du code en se basant sur des exemples existant sur Github.

ChatGPT permet de résoudre les problèmes simples juste en copiant l'énoncé
. Dès que les problèmes sont un peu plus complexes, ChatGPT est rapidement perdu, et il faut décrire précisément les problèmes, travailler par étape et le guider pour trouver la solution. ChatGPT ne comprends pas ce qu'il fait. Sur les problèmes vraiment complexes, il est perdu et n'arrive à rien faire.

ChatGPT : très créatif et explique ce qu'il fait, mais il pense qu'il a toujours raison même quand il a tort.

Github Copilot : bon programmeur et intégré dans l'IDE, mais il manque de recul sur ce qu'il fait, et copie trop sur ses voisins (récupère du code de GitHub)

En conclusion, ChatGPT est utile pour trouver des idées, Copilot pour coder, mais il faut toujours vérifier les résultats, on ne peut pas faire une confiance aveugle dans ces outils.

== JEUDI

Programme du jeudi : https://cfp.devoxx.fr/2023/byday/thu

=== 10h45 - 11h30 : CRAC vs GraalVM

==== Abstract

Dans les cas d'usages modernes (Kubernetes, Serverless), tout le monde sait que le point noir de la JVM est son démarrage.

Depuis quelques années, GraalVM s'impose comme remède permettant ainsi un démarrage rapide via une compilation native. Cela apporte néanmoins certaines contraintes.

Une nouvelle solution apparait dans le paysage de la JVM. C'est CRaC pour Coordinated Restore at Checkpoint. Regardons ensemble comment cela fonctionne et les avantages.

==== Speakers

_Lilian BENOIT_

Lilian est Tech Leader dans une ESN Bordelaise. il est passionné par l'informatique depuis bien plus longtemps. Il aime travailler sur sa plateforme préféré Java (Java SE et Jakarta EE), notamment sur sa distribution de prédilection : Debian.

Il adore apprendre et partager ses connaissances. C'est comme cela qui s'est rapproché du BordeauxJUG dont il en est JUG Leader depuis 2016. L'objectif du Bordeaux JUG est de promouvoir Java à travers des soirées/conférences mensuelles autour de la plateforme Java.

==== Notes

Changement de paradigme :

* Usage de micro-services
* Diminution de l'usage des serveurs d'application
* Approche stateless
=> besoin de démarrage rapide

Fonctionnement de la JVM :

* Bytecode interprété
* Code "préchauffe", nécessité de passer plusieurs fois dans une méthode pour l'optimiser.
* Compilateur JIT

Avec Java :
Chargement de classes, prises en compte des annotations, initialisation du contexte applicatif de CDI, ce qui prend du temps mais grande flexibilité

GraalVM :
Exécutable natif et compilateur AOT

Contraintes de GraalVM:

* Réflexion et dynamiques : tout doit être connu au moment de la compilation, la réflexion ne fonctionne pas. 
* Utilisation de Substrate VM pour remplacer la JVM
* SerialGC comme Garbage Collector (le moins performant)
* Optimisation à chaud (GraalVM Entreprise uniquement)
* GC G1 à faible latence présent dans la version Entreprise

CRaC : Coordinated Restore  at Checkpoint
C'est un concurrent de GraalVM. Il est maintenu par OpenJDK.

Checkpoint : fige l'état de la JVM "déjà chaude" au moment d'un checkpoint, puis plus tard possibilité de restaurer la JVM au moment de ce checkpoint

2 méthodes à implémenter: beforeCheckpoint et afterCheckpoint.
La JVM s'arrête au moment où on demande un checkpoint => faire attention de bien fermer les connexions/socket avant, et de tout rouvrir au moment du chargement du checkpoint.

Les frameworks comme Springboot sont en train de s'adapter pour éviter au développeur de gérer ce genre de problème.

=== 11h45 - 12h30 : Bien choisir sa base de données

==== Abstract

RDBMS ? Orienté colonnes ? Documents ? Timeseries ? Graphes ? Distribué ou non ? Pas facile de faire le bon choix lorsqu’on est perdu dans toutes ces notions. Dans ce talk, on est là pour t’aider à faire le meilleur choix de base de données pour ta prochaine application ! Comme la solution universelle n’existe pas, on va plutôt te présenter différents critères de choix, les pièges et antipatterns qu’il faut éviter, ainsi qu’une lecture analytique de chaque type de DB. On va notamment parler des grands types de bases de données, de transactions et de distribution de la donnée. En sortant, tu te poseras les bonnes questions pour choisir ta BDD et tu n’auras pas besoin de chercher à faire des jointures dans Elastic !

==== Speakers

_Sébastien Keller_

S’il n’est pas en train de faire sa séance de bloc quasi-quotidienne, vous pourrez trouver Sébastien en train de répondre à des questions sur son diagramme d’archi ou de lire le code de Kafka Stream pour trouver le bon TaskAssignor.
Après 11 ans, et quelques générations de juniors formées, Sébastien se décide enfin à partager son expérience à un public plus large.
Côté métier, il a travaillé sur des codebases aussi variées que de l’assurance, des sites e-commerce et plus récemment, de la Big Data. Il pourra vous parler de toutes les mauvaises idées qu’il a croisé sur son chemin, mais aussi des bonnes !

_Alexandre Budzko_

Jeune developpeur fullstack, passionné par la tech et en particulier le free software

==== Notes

DBs relationnelles :

Dbs orientées documents :MongoDb, CouchDB

DBs search : algolia, ealsticsearch

Axes de décision :
Structure, dimensionnement, runtime

Type de requête : recherche par identifiant, recherche par champ secondaire
recherche par score

Contraintes spécifiques,style géospatial

=== 13h00 - 13h15 : Storybook, une vraie bonne idée ?

==== Abstract

Ça y est, vos designers ont enfin mis en place un design system complet pour assurer une maintenabilité, homogénéité et accessibilité des composants UI de votre interface. Mais comment s'assurer du respect de celui-ci et des bonnes pratiques front-end dans une équipe à l'appétence très fortement back-end ? Depuis 2 ans, notre équipe hésitait à utiliser Storybook, un outil front-end pour créer une UI propre et documentée isolée. Est-ce que la notoriété est justifiée ? Est-ce que Storybook correspondrait à une équipe réduite comme la nôtre ? Je partagerai nos réflexions, nos choix, l’histoire de l’intégration de Storybook au sein de notre équipe et vous découvrirez si oui ou non, nous l’avons déployé.

==== Speakers

_Sara Attallah_

Développeuse depuis 5 ans, je suis actuellement en charge du Front-End chez JOLIMOI, en plein écosystème Vue JS. Après un parcours artistique et dans le cinéma documentaire, je me passionne pour les interfaces interactives au cours de la création d'un web documentaire. J'ai commencé ma carrière dans des studios de design interactifs et m'épanouis dans le web depuis.

==== Notes

Besoin d'un code réutilisable avec la documentation associée.
Approche Design System choisie => catégoriser tous les composants graphiques pour en faire une bibliothèque réutilisable.

image::PXL_20230413_110713126.jpg[alt]

Storybook permet de faire un catalogue de composants et de leur différents états.
Les différentes propriétés graphiques sont retrouvées et peuvent être modifiée à la volée pour tester le composant.
Il existe une existe docs pour décrire dans un markdown la documentation du composant.
Pas mal de maintenance à prévoir dès qu'un composant évolue. Nécessité de faire des composants isolés et une bonne organisation => en parallèle de la création d'un nouveau composant, il faut aussi faire la partie storybook et la maintenir.

Retex très positif de la part du speaker sur l'outil.

Exemple de Storybook de Doctolib :
https://oxygen.doctolib.design/60b411768/p/77fd2d-doctolib-design-system

Storybook peut être intéressant pour remplacer le sample Titan qui va devenir de plus en plus difficile à maintenir.

=== 13h45 - 14h30 : Loi de Conway : lorsque les bonnes pratiques ne suffisent pas

==== Abstract

Avez-vous des APIs découpées d'une manière qui semble au final arbitraire et orthogonale au métier ? Que l'architecture décidée n'est jamais vraiment respectée ni réalisée ?

Vos utilisateurs ont toujours du mal à récupérer les informations dont ils ont besoin, alors que vous avez mis le paquet sur le métier et l'expérience utilisateur ?

N'avez-vous jamais remarqué, que bien vous suivez les bonnes pratiques, le logiciel qu'on construit s'écarte souvent de la vision produit, technique et parfois même des besoins de l'utilisateur ?

Et si on vous disait que tout cela est lié, et qu'il existe une force qui a une influence certaine sur votre produit, votre expérience utilisateur, votre architecture et même la qualité de votre logiciel ?

Venez découvrir la Loi de Conway ! Cette force méconnue qui a un pouvoir certain sur ce que vous construisez quel que soit votre métier. A travers des études scientifiques et des retours du terrain sur des exemples réels, nous verrons ses impacts sur les différents aspects du logiciel et nous apprendrons comment les apprivoiser.

==== Speakers

_Julien Topçu_

Tech Coach chez Shodo, j'accompagne le développement de logiciels à forte valeur métier en usant de techniques issues du Domain-Driven Design, le tout propulsé en Xtreme Programming dans la philosophie Kanban #NoEstimates. Membre de la fondation OWASP, j'évangélise sur les techniques de sécurité applicative afin d'éviter de se faire hacker bien comme il faut.

==== Notes

La qualité du produit est liée à l'organisation de l'entreprise.
Lien entre structure du système et l'organisation qui l'a produit.

Règle de l'homomorphisme : la structure de l'organisation fait que le 2e système ne sera pas choisi, ni même imaginé par les équipes, chacun ayant déjà une manière de penser et d'intéragir entre elles. Pourquoi ajouter une nouvelle équipe à l'existant ?

L'effort de communication n'est pas linéaire, l'effort de travail non plus (à revoir)

Il faut limiter la communication et les intermédiaires pour faire une meilleur travail.

Il faut rester flexible dans son organisation.

Inverse Conway Maneuver : il faut casser les silos en entreprise pour améliorer la communication.

BAPO
Domaine Driven Design permet de résoudre les problèmes B et A
B->A: définition des sous système.

ContextMap
PartnerShip

DDD ne donne pas beaucoup de billes sur comment s'organiser.

Team Topologies va traiter P -> O.
Il ne faut pas surcharger le travail de l'équipe.

Collaboration
Réduire l'interaction entre les équipes pour qu'elles soient le plus autonome possible.

=== 14h30 - 15h15 : Les nouveautés de Java 19 et 20

==== Abstract

Les versions 19 et 20 de Java, publiées en septembre et mars derniers, sont les 10eme et 11eme release en application du modèle de release tous les 6 mois.

En attendant la publication de Java 21, la prochaine version LTS publiée en septembre de cette année, et pour en donner quelques aperçus, cette présentation brosse une revue détaillée des nouveautés introduites dans ces nouvelles versions non-LTS de Java, issues des projets Amber, Panama et Loom d’OpenJDK ainsi que des fonctionnalités non incluses dans des JEPs.

==== Speakers

_Jean-Michel Doudoux_

Passionné par le développement de logiciels et par la veille technologique, je possède une longue expérience, en SSII/ESN et personnelle, dans l'écriture d'applications avec différents langages. Je suis actuellement Senior tech lead pour la société Sciam. Utilisant Java depuis sa version 1.0, j'aime partager ma passion pour cette plateforme et son écosystème notamment en me consacrant, depuis presque vingt années, à la rédaction de deux tutoriels, intitulés "Développons en Java", diffusés sous licence GNU FDL. Ce travail m'a permis d'être nommé Java Champion. Je suis également un des cofondateurs du Lorraine JUG.

==== Notes

Record Patterns en preview

image::path[alt]

Pattern matching for switch 

Foreign Function & Memory API

Vector API

Virtual Threads avec Loom

Structured Concurrency

=== 13h45 - 16h30 : DevOps is Dead? Au fait, c’est quoi le DevOps? Et pourquoi faut-il le sécuriser?

==== Abstract

Après 14 ans de DevOps, il est temps pour nous de regarder ce qui font les forces et les faiblesses du mouvement DevOps. Il y cinq ans, nous avons écrit le livre “Liquid Software”. Nous étions sûrs qu’aujourd’hui la vision serait âgée et dépassée, mais elle est plus que jamais un facteur déterminant dans le succès d’une transformation digitale. Dans cette session, je parlerai du présent et du futur du DevOps dans notre industrie changeante, et comment votre entreprise peut bénéficier au maximum du mouvement DevOps.

==== Speakers

_Fred Simon_

Fred est le cofondateur de JFrog, et l’un des architectes les plus respectés de la communauté des développeurs, avec plus de 20 ans d’expérience Java et Open Source. Avant JFrog, Fred a fondé AlphaCSP, où il dirigeait 5 branches dans le monde en tant que CTO et visionnaire. Fred a traversé les évolutions de technologies dans son rôle de programmateur, architecte, consultant, et speaker. Fred est titulaire d’un Masters in Computer Science de l’école Centrale de Lille.

==== Notes

Dans le Devops, l'idéal est pas d'intervention humaine entre le commit et la mise en production.
Mais l'humain aime rester dans le "flow" pour se sentir important. Il faut travailler main dans la main avec les machines pour être plus performant.

image::PXL_20230413_134745523.jpg[alt]

La prochaine étape du Devops : uniquement des machines à partir du commit du développeur (code review, review des vulnérabilités, end-to-end testing, ...). Le speaker aimerait que la chaine de prod soient entièrement automatisée pour que la mise en prod soit la plus rapide possible. 

Mettre à jour Edge device

Bref, le devops n'est pas mort, et on gagnerait beaucoup de temps à automatiser le maximum d'étapes avant la mise en prod

=== 16h45 - 17h30 : Auth et systèmes distribués: ne jetons pas le bébé avec l'eau du bain

==== Abstract

Depuis l'essor des architectures microservices, l'auth a bien évolué. Les solutions basées sur un serveur d'authorisation central sont certes simples à mettre en place, mais rendent les systèmes moins résilients. Si le serveur d'auth tombe, l'ensemble de la plateforme tombe. De l'autre côté du spectre, des systèmes à base de jetons au porteur (comme JWT) permettent de s'affranchir des contraintes d'un système centralisé. En revanche, de tels systèmes sont notoirement complexes à mettre en place et nécessitent une bonne dose d'expérience pour éviter les erreurs.

Dans cette conférence nous vous présenterons:

* comment choisir entre un système d'auth centralisé et un système distribué
* un tour d'horizon des solutions possibles pour les jetons au porteur;
* les différentes architectures d'auth possibles (passerelle d'auth, intégration directe, …);
* les éléments indispensables à mettre en place dans un tel système (rafraichissement des tokens, révocation, rotation des clés, …);
* la plateforme biscuit, construite autours de ces use cases.

==== Speakers

_Clément Delafargue_

I'm a functional programmer, working on IAM matters at Outscale

_Geoffroy Couprie_

Geoffroy Couprie est consultant indépendant. Spécialiste en sécurité logicielle, il travaille à rendre le code plus sûr, et les outils cryptographiques plus utilisables. Il étudie plus particulièrement la sécurité des protocoles d'authentification et d'échange de messages.

==== Notes

Authentification sur les systèmes distribués.
Possibilité de centraliser le système d'auth.

Bearer tokens :
JWT (commun mais peu être tricky)
PASEO ()

Bearer Tokens (fancy) :
Macaroons
Biscuit

Ne pas oublier de mettre en place une architecture de révocation (très important !!) :
* les tokens doivent être uniques
* maintenir une liste des tokens émis (avec un id unique dans la liste)
* les tokens doivent avoir une date d'expiration

Système pour mitiger cette limitation :

image::PXL_20230413_145843189.jpg[alt]

Mettre en place un système de rotation de clé, et le faire régulièrement.

Offline attenuation : si on a un jeton valide, on peut générer un nouveau token avec moins de droits, comme changer la date d'expiration.
Utilisation de Biscuit pour cela : https://www.biscuitsec.org.
Implémentation en JS, Java, Go, Rust...

slide avant hot path à mettre
Bonne architecture mais il faut être carré sur la révocation des clés.

La librairie me semble assez intéressante, mais pas assez mature pour utiliser chez nous à mon avis.

=== 17h45 - 18h15 : Dockerfile vs Jib vs Pack vs image native : quelle est la meilleure méthode de création d'image de conteneur

==== Abstract

Docker est l'outil standard pour créer et exécuter des conteneurs sur la plupart des plateformes. La façon traditionnelle pour construire l'image d'un conteneur est intégrée à l'outil Docker et utilise une séquence d'instructions spéciales, généralement dans un fichier nommé Dockerfile, pour compiler le code source et assembler les "layers" d'une image de conteneur.

Mais Docker n'est pas la seule façon de construire les images des applications conteneurisées. Dans cette présentation, nous allons construire des images de conteneurs à l'aide de différentes méthodes, puis nous comparerons les constructeurs et évaluerons les images de conteneurs respectives : Nous examinerons différentes propriétés telles que la taille de l'image, le score d'efficacité, la sécurité, la facilité d'utilisation et la compatibilité des méthodes avec les langages de programmation. Mais aussi, nous allons démarrer les conteneurs pour effectuer plusieurs benchmarks. Tout cela afin de vous aider à déterminer quel est la meilleure approche pour vous !

==== Speakers

_Christian NADER_

Senior software engineer at Decathlon, working on Digital Supply projects and Data Streaming solutions. Beforehand, I worked for the French government on projects like securing citizens' healthcare data and developing the french digital signature service. A scientist by training, I always apply the scientific method when solving IT problems. Interested in everything tech, development, design and architecture.

==== Notes

Images Distroless : ne contient que l'application et les dépendances runtime. Utilisation de Jib pour les images distroless. Image plus petite, surface d'attaque réduite, démarrage plus rapide, mais moins customisable qu'une image générée par un dockerfile.

Cloud native buildpacks (CNB) : convertit le code source depuis n'importe quel langage vers un système de conteneur

== VENDREDI

Programme du vendredi : https://cfp.devoxx.fr/2023/byday/fri

=== 10h45 - 11h30 : Clean as You Code your projects

==== Abstract

On veut tous un code de qualité - “Clean Code”. Mais à mesure que notre code et nos équipes s'agrandissent, il peut être difficile de maintenir cette norme. Dans cette présentation, nous aborderons les bénéfices du “Clean Code” et comment vous concentrer sur ce point aidera votre organisation et vous même à prospérer. Nous approfondirons le concept de “Clean as You Code” et les outils qui garantissent un code adapté au développement et à la production.

==== Speakers

_Nolwenn Cadic_

Nolwenn fait partie de l’équipe SonarCloud où elle fait du développement Java. Elle a rejoint l’équipe il y a un an. Elle y cultive son goût du Clean Code et le met en pratique tous les jours. Avant l’aventure SonarSource, elle a travaillé 2 ans comme développeur full stack Java et React.

_Marco Comi_

Marco Comi est un Chef de Produit avec plus de 13 ans d'expérience dans l'industrie du logiciel. Il a commencé sa carrière comme ingénieur logiciel, où il a développé une profonde appréciation du Clean Code et de l'importance de soutenir les développeurs dans leur quête pour l'écrire. Il a ensuite travaillé comme Scrum Master, Product Owner et finalement a effectué la transition vers la gestion de produits. Il travaille chez SonarSource et supervise le développement de SonarLint depuis 2020.

==== Notes

Clean code = code adapté à un but

image::PXL_20230414_085300107.jpg[alt]

Le clean code minimise l'effort et le cout d'entretien, réduit la friction pour les développeurs, augmente la longévité du logiciel et réduit les couts (x3) et réduit les risques opérationnels et de sécurité.

Approche de Sonar : Clean as you Code

A ne pas faire : repartir de 0, faire un gros refactoring. 

Clean as you Code = régler le problème avant de réparer les conséquences. Basé sur le concept de nouveau code. Le nouveau code doit être du clean code. Cela permet de régler le problème avant les conséquences. Pas de réécriture donc ne bloque pas les évolutions. Chaque développeur est responsable du code qu'il écrit. Utilisé avec succès depuis des années chez Sonar.

Une seule et simple règle : aucun nouveau code non clean Code déployé en production. Pour cela, on utilise des Quality Gate (ce qu'on fait déjà chez nous, donc rien de nouveau de ce côté là, mais leur Quality Gate est beaucoup plus stricte que la notre).

Publicité pour SonarLint, SonarQube et SonarCloud. Dans la Quality Gate par défaut, Sonar demande 80% de couverture de tests, et utilise 90% de couverture en interne.

En utilisant cette technique, le vieux code est réécrit progressivement et donc remplacé par du Clean Code au fur et à mesure. Ecrire du code propre, ça ne coute pas plus cher que d'écrire n'importe quoi.

=== 11h45 - 12h30 : Avoir de l’impact en tant qu’Engineering Manager

==== Abstract

Après 5-10 ans passés à coder dans une équipe vient LA question : dois-je vraiment devenir Manager ? Cette question peut résonner avec une crise existentielle. Dois-je coder toute ma vie ? Je vais faire quoi en vrai en attendant la retraite à 127 ans ?

Bon nombre d’organisations modernes mettent en place un double chemin de carrière. La première “Individual Contributor” permettant de s’épanouir et de grandir en tant que developp(eur | euse). L’autre est celle de l’“Engineering Management” permettant de s’épanouir et de grandir en tant que Manager (Engineering manager, Head of Engineering, VP, …).

Cette seconde voie peut paraître obscure au premier abord, mais nous reviendrons sur ce rôle (aux côtés des product managers, des tech leaders etc …) et les différents challenges associés dans un contexte de forte croissance (ou non) et détaillerons les compétences à développer pour avoir de l’impact en tant que manager et grandir et faire grandir.

Cette conférence est le complément manager de la conférence de 2022, sur la carrière de contributeur individuel - link:https://youtu.be/X5MYKj1C2qM[Développ(eur l euse) Senior avec 6 ans d’expérience, et après ?]

==== Speakers

_Dimitri BAELI_

Member of the Tech staff at BackMarket working on the tech org and an internal startup to provide refurbished devices for entreprises. I also occasionally mentor CTO/CEO, while actively contributing to the FlowCon Conference & the Tech.Rocks Tech Leaders network. 20+ years IT and Product Leadership and Exec member at AramisAuto, LesFurets.com, eXoPlatform, setting up and running IT Teams based on Agile & Craftmanship principles. Based on team autonomy to work with Continuous Improvement of a high quality software.

_Benoit Guillon_

VP engineering at Malt since 2019 +20 years experience in tech Started engineering management at Talend 6 years ago in a hyper scaling context

==== Notes

Typical Product Team structure :
1 Product Manager
1 Engineering Manager
X Team Members (Dev, QA, Design, Ops)

image::PXL_20230414_095228263.jpg[alt]

image::PXL_20230414_100053798.jpg[alt]

image::PXL_20230414_101000349.jpg[alt]

image::PXL_20230414_101329663.jpg[alt]

image::PXL_20230414_102229927.jpg[alt]

image::PXL_20230414_102558236.jpg   [alt]

=== 11h45 - 12h30 : 6 Tips pour améliorer sa Web App Angular

==== Abstract

Si Angular est d’apparence plus simple à découvrir (merci les tutos Google), il est probablement plus complexe à maîtriser que ses comparses. Dans ce quickie, je vous propose 6 tips, du plus évident au plus caché, qui ont changé la donne dans le code de nos apps, que ce soit en termes de performances ou de lisibilité. Qu’importe votre niveau sur le sujet, je parie sur le fait qu’il y aura du nouveau pour tous !

==== Speakers

Rien ne présageait que Camille ferait du web. Plutôt destinée à une carrière dans les systèmes embarqués, c’est finalement le dev, qui l’a embarquée il y 2 ans. Sur le chemin, elle découvre son talent de leadership et se dit qu’au final, elle pourrait aussi emmener du monde avec elle dans sa quête de connaissance et de veille ! Adepte de meetups comme certains, fan de frameworks comme beaucoup, elle connaît TypeScript jusqu’au bout des ongles et prend parfois son clavier pour partager ce qui l’anime au quotidien.

==== Notes

Astuce 1 : les alias

Astuce 2 : TrackBy

=== 13h30 - 14h15 : Docker au service du DevSecOps

==== Abstract

Chez La Poste docker est devenu un élément clé de la démarche DevSecOps et de notre démarche Move To Cloud. Dans une entreprise comme La Poste, il est important d'automatiser, de sécuriser, de simplifier et de généraliser les process de déploiement afin de permettre des mises en production transparentes et résilientes pour nos facteurs et nos utilisateurs. Afin d'y parvenir, nous avons mis en place des boites à outils (catalogues d'images Docker, templates de pipelines CICD, checks de sécurité, etc.) afin de permettre aux équipes applicatives de déployer leurs applications sur le cloud avec le minimum d'effort. Nous utilisons docker à chaque étape que ça soit pour donner un cadre technique aux projets, mais aussi pour vérifier que les projets respectent les bonnes pratiques recommandées. C’est pourquoi pendant la présentation, je vais expliquer comment nous utilisons docker à La Poste pendant le développement (optimisation de cache, catalogue d'images), la sécurisation (scan des images, patch management, SAST, DAST) et le déploiement rapide et automatisé des applications (CI/CD). La présentation sera accompagnée d'exemples concrets d'implémentation.

==== Speakers

_Carmen Piciorus_

Toujours passionnée par la tech, le dev et la sécurité, je suis toujours contente de partager mes connaissances et toujours en quête de perfectionnement et de l'épanouissement. Après 6 ans de missions en tant que développeur, j'ai rejoins le groupe La Poste en tant qu'abuse manager pour la messagerie laposte.net, et ensuite expert technique et sécurité (kubernetes, docker, gitlab-ci) pour la DSI BSCC.

Par ailleurs je suis présidente de l’association Signal spam, engagée dans la lutte contre le spam.

==== Notes

Déploiement des applications dans le cloud de manière sécurisée

Pour le développeur => utilisation d'un catalogue d'images interne et recommandé. Même principe que pour la création d'OS sécurisé chez nous. A partir d'une image officielle, on enlève ce qui n'est pas nécessaire (en collaboration avec chaque projet) et on scanne ce qui reste à la recherche de vulnérabilités et de failles de sécurité.

Ecriture du dockerfile par les développeurs chez la Poste, diminution de la taille de l'image finale avec des builds multi-stage. Utilisation de docker-compose pour démarrer plusieurs images (back et front) en même temps. Buildpacks pour transformer le code en image Docker pour les projets legacy sans pipeline.

Outils de détection de vulnérabilités : scan statique du code source avec SAST (Static application security testing) et SCA (scan des dépendances et des licenses avec dependency-check). Scan dynamique de l'application en exécution avec zap (owasp/zap2docker-bare). Scan du catalogue d'images et scan des images projet.

Fuite de données => pas de secrets dans les configmap, ni dans les variables d'environnement de l'image.

Base de connaissance ELK : état de santé des applications.

=== 14h30 - 15h15 : 1, 2, 3 Quarkus!

==== Abstract

Quarkus est une stack pour écrire des applications Java pour le Cloud. En réduisant l’emprunte mémoire et le temps de démarrage, les applications Quarkus permettent en autre d’augmenter la densité de déploiement, le développement d’application serverless en Java, un meilleur comportement dans Kubernetes…

La première release publique de Quarkus a été faite en Mars 2019. Nous voilà 4 ans plus tard avec Quarkus 3.x. Entre temps, Quarkus a grandi, son écosystème s’est enrichi. Mais, Quarkus est resté fidèle à ses principes.

Cette présentation rappelle les points fondamentaux de Quarkus (build-time principle, reactive core, container-first) et explique leur évolution au cours de ces 4 dernières années ainsi que les nouveautés de Quarkus 3.x tels que la nouvelle dev ui, l’intégration d’Hibernate 6, le passage à Jakarta et à Flow, le support des threads virtuels, les différentes améliorations de l’expérience pour les développeurs, le support des architectures ARM…

==== Speakers

_Clement Escoffier_

Clement Escoffier (@clementplop) is a distinguished engineer at Red Hat. He is a Java Champion, author, and also acts as a Reactive Architect at Red Hat. Before joining Red Hat, Clement had several professional lives, from academic positions to management. Clement has always been interested in software engineering, distributed systems, and event-driven architecture. He recently focused on Reactive Systems, Cloud-Native applications, and Kubernetes. Clement actively contributes to many open-source projects, such as Eclipse Vert.x, SmallRye, Mutiny, and Quarkus.

_Aurea Munoz Hernandez_

Développeuse java focalisée sur l'intégration de Spring Boot et Spring Cloud dans le portfolio Red Hat Middleware. Je contribue aux projets spring boot et spring cloud pour améliorer l'expérience développeur.

==== Notes

Slides de la présentation : https://www.slideshare.net/clement.escoffier/devoxx-france-2023-123-quarkuspdf

Présentation des nouveautés de Quarkus 3 au travers d'une démo codée en live, très orientée Cloud, Kubernetes, Kafka

mettre une capture d'écran

=== 15h30 - 16h15 : L'étonnante efficacité des petits pas

==== Abstract

"Qui va lentement va surement !"

Changement de spec, changement du code, perte de connaissance, changement de techno, changement d'équipe, changement du marché … Ecrire du code est complexe ! Dans un environement complexe, il faut avancer par petit pas. Coder par petit pas, c'est découper les taches de développement en petits incréments.

Assistez à ce talk pour comprendre pourquoi coder en petits pas est LA pratique que vous devriez apprendre MAINTENANT ! En plus :

* Vous partagerez vos histoires de développement par petit pas.
* Vous entendrez comment je suis tombé dans la marmite des petits pas !
* Vous découvrirez comment les petits pas impactent d'innombrables aspects de notre travail : Test, Commit, Qualité, Risque, CI, CD, Priorisation, Rythme, Fatigue, Travail en équipe, Suivi du travail, Legacy, et Refactoring ...!
* Vous comprendrez pourquoi les petits pas sont importants grâce à la théorie Cynefin.
* Vous apprendrez comment prendre des petits pas, même dans un environement difficile !
* Vous poserez un premier pied sur le chemin des pas toujours plus petits.
Venez (re-)découvrir la compétence la plus sous-estimée du développement !

==== Speakers

_Philippe Bourgau_

Coach eXtreme Programming et Hacktivist du rythme soutenable !

La vie est trop courte pour perdre son temps! J'aide les développeurs à atteindre un rythme soutenable et une productivité durable grâce au refactoring continu de leur code, mais aussi de leur environnement de travail !

Je travaille actuellement à Murex

==== Notes

Amélioration progressive, tout marche toujours, mais il faut une bonne couverture de code. Petits commits, facilite le travail collaboratif, les merges sont simplifiés.

TCR : test and commit, or reverse

https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html

https://github.com/murex/TCR

=== 16h45 - 17h30 : Quoi de neuf dans CDI 4.0 ?

==== Abstract

Jakarta Contexts and Dependency Injection est probablement la spécifications la plus sous-estimée de Jakarta EE. Et pourtant, elle constitue la pierre angulaire de Jakarta EE et de MicroProfile en fournissant un modèle de programmation standardisé et une manière puissante d'intégrer des technologie tierces de manière transparente.

La version 4 de CDI est au cœur de Jakarta EE 10 et MicroProfile 6.0 qui sont sorties fin 2022. Il parait donc intéressant d’explorer les nouveautés de la spécification pour voir ce qu’elle apporte à ces 2 stacks

Dans cette présentation, nous passerons donc, en revue toutes les nouvelles fonctionnalités de la spécification et nous nous concentrerons sur CDI lite qui a permis de créer un nouveau profil Jakarta EE (le Core Profile) et prend en charge les approches d’injection de dépendance au build time comme le font Quarkus ou Micronaut.

Nous passerons en revue la nouvelle API d'extension et verrons comment elle diffère des Portable Extensions historiques.

A l’issue de ce talk vous serez en mesure de commencer le développement d’une extension CDI Lite pour votre framework préféré pour vous préparer aux futures versions de Quarkus et Micronaut.

==== Speakers

_Antoine Sabot-Durand_

Antoine est un Java Champion et l’ancien spec lead de Jakarta EE CDI. Il a fait partie de l’équipe de lancement de Quarkus chez Red Hat et à travaillé sur des specs MicroProfile majeures comme Fault Tolerance ou Health Check. Aujourd’hui, Antoine est architecte et expert technique chez SCIAM. Il pilote des projets complexes en utilisant en grande partie les technologies qu’il a contribué à mette au point.

==== Notes

Dans CDI 4.0, par défaut, seul les beans annotés sont trouvés.

CDI Lite : empreinte mémoire beaucoup plus légère pour les environnement contraints et le cloud. Le but est de fournir un sous ensemble CDI le plus grand possible pour que les fonctionnalités fondamentales de CDI puissent fonctionner. Les premiers cibles de CDI Lite sont Quarkus et Micronaut.

Ce qui n'est pas dans CDI Lite : 
* Les Decorators
* @Session et @Conversation
* les standard Portable extension

Quarkus 3 va utiliser CDI 4.0 à travers ArcDI, et les extensions propriétaires devront être mise à jour.

===== A rattraper en replay

* Docker Compose 101 (++)
* Kubernetes, dépassionné et pour les ultra débutants (+++)
* Comprendre et utiliser les modèles de langage d'IA (++)
* Jakarta en 2023, Quelle est la situation ? (+)
* Finis les 'git commit -m "fix pipeline #42"' grâce à Dagger (+)
* Playwright : l'outil qui va révolutionner les tests end-to-end (++)
* Redis: du cache à la time series! (+)
* Savez-vous vraiment comment fonctionne git ? (+++)
* Ah, tu peux faire ça en CSS maintenant ? (+)
* GC: Comment dompter la bête et en faire votre meilleur allié (++)
* Programmation Concurrente et Asynchrone : Loom en Java 20 et 21 (++)
* Je malmène ta prod en direct avec 15 failles de sécu (++)
* Voyage au centre de la Veille : Apprendre en continu avec sa veille technologique (+)

A regarder : Decathlon, Blablacar, cosium, Axa, Takima, github, sonar

https://www.npmjs.com/package/eslint-plugin-rxjs-angular